# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/gamm/v1beta1/pool.proto, osmosis/gamm/v1beta1/query.proto, osmosis/gamm/v1beta1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class PoolAsset(betterproto.Message):
    # Coins we are talking about, the denomination must be unique amongst all
    # PoolAssets for this pool.
    token: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    # Weight that is not normalized. This weight must be less than 2^50
    weight: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SmoothWeightChangeParams(betterproto.Message):
    """
    Parameters for changing the weights in a balancer pool smoothly from a
    start weight and end weight over a period of time. Currently, the only
    smooth change supported is linear changing between the two weights, but
    more types may be added in the future. When these parameters are set, the
    weight w(t) for pool time `t` is the following:   t <= start_time: w(t) =
    initial_pool_weights   start_time < t <= start_time + duration:     w(t) =
    initial_pool_weights + (t - start_time) *       (target_pool_weights -
    initial_pool_weights) / (duration)   t > start_time + duration: w(t) =
    target_pool_weights
    """

    # The start time for beginning the weight change. If a parameter change /
    # pool instantiation leaves this blank, it should be generated by the
    # state_machine as the current time.
    start_time: datetime = betterproto.message_field(1)
    # Duration for the weights to change over
    duration: timedelta = betterproto.message_field(2)
    # The initial pool weights. These are copied from the pool's settings at the
    # time of weight change instantiation. The amount PoolAsset.token.amount
    # field is ignored if present, future type refactorings should just have a
    # type with the denom & weight here.
    initial_pool_weights: List["PoolAsset"] = betterproto.message_field(3)
    # The target pool weights. The pool weights will change linearly with respect
    # to time between start_time, and start_time + duration. The amount
    # PoolAsset.token.amount field is ignored if present, future type
    # refactorings should just have a type with the denom & weight here.
    target_pool_weights: List["PoolAsset"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class PoolParams(betterproto.Message):
    """
    PoolParams defined the parameters that will be managed by the pool
    governance in the future. This params are not managed by the chain
    governanace. Instead they will be managed by the token holders of the pool.
    The pool's token holders are specified in future_pool_governor.
    """

    swap_fee: str = betterproto.string_field(1)
    exit_fee: str = betterproto.string_field(2)
    #
    smooth_weight_change_params: "SmoothWeightChangeParams" = betterproto.message_field(
        3
    )


@dataclass(eq=False, repr=False)
class Pool(betterproto.Message):
    address: str = betterproto.string_field(1)
    id: int = betterproto.uint64_field(2)
    pool_params: "PoolParams" = betterproto.message_field(3)
    # This string specifies who will govern the pool in the future. Valid forms
    # of this are: {token name},{duration} {duration} where {token name} if
    # specified is the token which determines the governor, and if not specified
    # is the LP token for this pool. duration is a time specified as 0w,1w,2w,
    # etc. which specifies how long the token would need to be locked up to count
    # in governance. 0w means no lockup. TODO: Further improve these docs
    future_pool_governor: str = betterproto.string_field(4)
    # sum of all LP tokens sent out
    total_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(5)
    # These are assumed to be sorted by denomiation. They contain the pool asset
    # and the information about the weight
    pool_assets: List["PoolAsset"] = betterproto.message_field(6)
    # sum of all non-normalized pool weights
    total_weight: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class MsgCreatePool(betterproto.Message):
    """===================== MsgCreatePool"""

    sender: str = betterproto.string_field(1)
    pool_params: "PoolParams" = betterproto.message_field(2)
    pool_assets: List["PoolAsset"] = betterproto.message_field(3)
    future_pool_governor: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgCreatePoolResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgJoinPool(betterproto.Message):
    """===================== MsgJoinPool"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    share_out_amount: str = betterproto.string_field(3)
    token_in_maxs: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgJoinPoolResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgExitPool(betterproto.Message):
    """===================== MsgExitPool"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    share_in_amount: str = betterproto.string_field(3)
    token_out_mins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(
        4
    )


@dataclass(eq=False, repr=False)
class MsgExitPoolResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SwapAmountInRoute(betterproto.Message):
    """===================== MsgSwapExactAmountIn"""

    pool_id: int = betterproto.uint64_field(1)
    token_out_denom: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountIn(betterproto.Message):
    sender: str = betterproto.string_field(1)
    routes: List["SwapAmountInRoute"] = betterproto.message_field(2)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    token_out_min_amount: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountInResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SwapAmountOutRoute(betterproto.Message):
    """===================== MsgSwapExactAmountOut"""

    pool_id: int = betterproto.uint64_field(1)
    token_in_denom: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountOut(betterproto.Message):
    sender: str = betterproto.string_field(1)
    routes: List["SwapAmountOutRoute"] = betterproto.message_field(2)
    token_in_max_amount: str = betterproto.string_field(3)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgSwapExactAmountOutResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgJoinSwapExternAmountIn(betterproto.Message):
    """===================== MsgJoinSwapExternAmountIn"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    share_out_min_amount: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgJoinSwapExternAmountInResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgJoinSwapShareAmountOut(betterproto.Message):
    """===================== MsgJoinSwapShareAmountOut"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in_denom: str = betterproto.string_field(3)
    share_out_amount: str = betterproto.string_field(4)
    token_in_max_amount: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class MsgJoinSwapShareAmountOutResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgExitSwapShareAmountIn(betterproto.Message):
    """===================== MsgExitSwapShareAmountIn"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_out_denom: str = betterproto.string_field(3)
    share_in_amount: str = betterproto.string_field(4)
    token_out_min_amount: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class MsgExitSwapShareAmountInResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgExitSwapExternAmountOut(betterproto.Message):
    """===================== MsgExitSwapExternAmountOut"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    share_in_max_amount: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgExitSwapExternAmountOutResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryPoolRequest(betterproto.Message):
    """=============================== Pool"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolResponse(betterproto.Message):
    pool: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolsRequest(betterproto.Message):
    """=============================== Pools"""

    # pagination defines an optional pagination for the request.
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryPoolsResponse(betterproto.Message):
    pools: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryNumPoolsRequest(betterproto.Message):
    """=============================== NumPools"""

    pass


@dataclass(eq=False, repr=False)
class QueryNumPoolsResponse(betterproto.Message):
    num_pools: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolParamsRequest(betterproto.Message):
    """=============================== PoolParams"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolParamsResponse(betterproto.Message):
    params: "PoolParams" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalSharesRequest(betterproto.Message):
    """=============================== TotalShares"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalSharesResponse(betterproto.Message):
    total_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolAssetsRequest(betterproto.Message):
    """=============================== PoolAssets"""

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolAssetsResponse(betterproto.Message):
    pool_assets: List["PoolAsset"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QuerySpotPriceRequest(betterproto.Message):
    """=============================== SpotPrice"""

    pool_id: int = betterproto.uint64_field(1)
    token_in_denom: str = betterproto.string_field(2)
    token_out_denom: str = betterproto.string_field(3)
    with_swap_fee: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class QuerySpotPriceResponse(betterproto.Message):
    # String of the Dec. Ex) 10.203uatom
    spot_price: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountInRequest(betterproto.Message):
    """=============================== EstimateSwapExactAmountIn"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: str = betterproto.string_field(3)
    routes: List["SwapAmountInRoute"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountInResponse(betterproto.Message):
    token_out_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountOutRequest(betterproto.Message):
    """=============================== EstimateSwapExactAmountOut"""

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    routes: List["SwapAmountOutRoute"] = betterproto.message_field(3)
    token_out: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountOutResponse(betterproto.Message):
    token_in_amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalLiquidityRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryTotalLiquidityResponse(betterproto.Message):
    liquidity: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def create_pool(
        self,
        *,
        sender: str = "",
        pool_params: "PoolParams" = None,
        pool_assets: Optional[List["PoolAsset"]] = None,
        future_pool_governor: str = "",
    ) -> "MsgCreatePoolResponse":
        pool_assets = pool_assets or []

        request = MsgCreatePool()
        request.sender = sender
        if pool_params is not None:
            request.pool_params = pool_params
        if pool_assets is not None:
            request.pool_assets = pool_assets
        request.future_pool_governor = future_pool_governor

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/CreatePool", request, MsgCreatePoolResponse
        )

    async def join_pool(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        share_out_amount: str = "",
        token_in_maxs: Optional[List["___cosmos_base_v1_beta1__.Coin"]] = None,
    ) -> "MsgJoinPoolResponse":
        token_in_maxs = token_in_maxs or []

        request = MsgJoinPool()
        request.sender = sender
        request.pool_id = pool_id
        request.share_out_amount = share_out_amount
        if token_in_maxs is not None:
            request.token_in_maxs = token_in_maxs

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/JoinPool", request, MsgJoinPoolResponse
        )

    async def exit_pool(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        share_in_amount: str = "",
        token_out_mins: Optional[List["___cosmos_base_v1_beta1__.Coin"]] = None,
    ) -> "MsgExitPoolResponse":
        token_out_mins = token_out_mins or []

        request = MsgExitPool()
        request.sender = sender
        request.pool_id = pool_id
        request.share_in_amount = share_in_amount
        if token_out_mins is not None:
            request.token_out_mins = token_out_mins

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/ExitPool", request, MsgExitPoolResponse
        )

    async def swap_exact_amount_in(
        self,
        *,
        sender: str = "",
        routes: Optional[List["SwapAmountInRoute"]] = None,
        token_in: "___cosmos_base_v1_beta1__.Coin" = None,
        token_out_min_amount: str = "",
    ) -> "MsgSwapExactAmountInResponse":
        routes = routes or []

        request = MsgSwapExactAmountIn()
        request.sender = sender
        if routes is not None:
            request.routes = routes
        if token_in is not None:
            request.token_in = token_in
        request.token_out_min_amount = token_out_min_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountIn",
            request,
            MsgSwapExactAmountInResponse,
        )

    async def swap_exact_amount_out(
        self,
        *,
        sender: str = "",
        routes: Optional[List["SwapAmountOutRoute"]] = None,
        token_in_max_amount: str = "",
        token_out: "___cosmos_base_v1_beta1__.Coin" = None,
    ) -> "MsgSwapExactAmountOutResponse":
        routes = routes or []

        request = MsgSwapExactAmountOut()
        request.sender = sender
        if routes is not None:
            request.routes = routes
        request.token_in_max_amount = token_in_max_amount
        if token_out is not None:
            request.token_out = token_out

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountOut",
            request,
            MsgSwapExactAmountOutResponse,
        )

    async def join_swap_extern_amount_in(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in: "___cosmos_base_v1_beta1__.Coin" = None,
        share_out_min_amount: str = "",
    ) -> "MsgJoinSwapExternAmountInResponse":

        request = MsgJoinSwapExternAmountIn()
        request.sender = sender
        request.pool_id = pool_id
        if token_in is not None:
            request.token_in = token_in
        request.share_out_min_amount = share_out_min_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/JoinSwapExternAmountIn",
            request,
            MsgJoinSwapExternAmountInResponse,
        )

    async def join_swap_share_amount_out(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in_denom: str = "",
        share_out_amount: str = "",
        token_in_max_amount: str = "",
    ) -> "MsgJoinSwapShareAmountOutResponse":

        request = MsgJoinSwapShareAmountOut()
        request.sender = sender
        request.pool_id = pool_id
        request.token_in_denom = token_in_denom
        request.share_out_amount = share_out_amount
        request.token_in_max_amount = token_in_max_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/JoinSwapShareAmountOut",
            request,
            MsgJoinSwapShareAmountOutResponse,
        )

    async def exit_swap_extern_amount_out(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_out: "___cosmos_base_v1_beta1__.Coin" = None,
        share_in_max_amount: str = "",
    ) -> "MsgExitSwapExternAmountOutResponse":

        request = MsgExitSwapExternAmountOut()
        request.sender = sender
        request.pool_id = pool_id
        if token_out is not None:
            request.token_out = token_out
        request.share_in_max_amount = share_in_max_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/ExitSwapExternAmountOut",
            request,
            MsgExitSwapExternAmountOutResponse,
        )

    async def exit_swap_share_amount_in(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_out_denom: str = "",
        share_in_amount: str = "",
        token_out_min_amount: str = "",
    ) -> "MsgExitSwapShareAmountInResponse":

        request = MsgExitSwapShareAmountIn()
        request.sender = sender
        request.pool_id = pool_id
        request.token_out_denom = token_out_denom
        request.share_in_amount = share_in_amount
        request.token_out_min_amount = token_out_min_amount

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Msg/ExitSwapShareAmountIn",
            request,
            MsgExitSwapShareAmountInResponse,
        )


class QueryStub(betterproto.ServiceStub):
    async def pools(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryPoolsResponse":

        request = QueryPoolsRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/Pools", request, QueryPoolsResponse
        )

    async def num_pools(self) -> "QueryNumPoolsResponse":

        request = QueryNumPoolsRequest()

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/NumPools", request, QueryNumPoolsResponse
        )

    async def total_liquidity(self) -> "QueryTotalLiquidityResponse":

        request = QueryTotalLiquidityRequest()

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/TotalLiquidity",
            request,
            QueryTotalLiquidityResponse,
        )

    async def pool(self, *, pool_id: int = 0) -> "QueryPoolResponse":

        request = QueryPoolRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/Pool", request, QueryPoolResponse
        )

    async def pool_params(self, *, pool_id: int = 0) -> "QueryPoolParamsResponse":

        request = QueryPoolParamsRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/PoolParams", request, QueryPoolParamsResponse
        )

    async def total_shares(self, *, pool_id: int = 0) -> "QueryTotalSharesResponse":

        request = QueryTotalSharesRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/TotalShares", request, QueryTotalSharesResponse
        )

    async def pool_assets(self, *, pool_id: int = 0) -> "QueryPoolAssetsResponse":

        request = QueryPoolAssetsRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/PoolAssets", request, QueryPoolAssetsResponse
        )

    async def spot_price(
        self,
        *,
        pool_id: int = 0,
        token_in_denom: str = "",
        token_out_denom: str = "",
        with_swap_fee: bool = False,
    ) -> "QuerySpotPriceResponse":

        request = QuerySpotPriceRequest()
        request.pool_id = pool_id
        request.token_in_denom = token_in_denom
        request.token_out_denom = token_out_denom
        request.with_swap_fee = with_swap_fee

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/SpotPrice", request, QuerySpotPriceResponse
        )

    async def estimate_swap_exact_amount_in(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in: str = "",
        routes: Optional[List["SwapAmountInRoute"]] = None,
    ) -> "QuerySwapExactAmountInResponse":
        routes = routes or []

        request = QuerySwapExactAmountInRequest()
        request.sender = sender
        request.pool_id = pool_id
        request.token_in = token_in
        if routes is not None:
            request.routes = routes

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountIn",
            request,
            QuerySwapExactAmountInResponse,
        )

    async def estimate_swap_exact_amount_out(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        routes: Optional[List["SwapAmountOutRoute"]] = None,
        token_out: str = "",
    ) -> "QuerySwapExactAmountOutResponse":
        routes = routes or []

        request = QuerySwapExactAmountOutRequest()
        request.sender = sender
        request.pool_id = pool_id
        if routes is not None:
            request.routes = routes
        request.token_out = token_out

        return await self._unary_unary(
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountOut",
            request,
            QuerySwapExactAmountOutResponse,
        )


class MsgBase(ServiceBase):
    async def create_pool(
        self,
        sender: str,
        pool_params: "PoolParams",
        pool_assets: Optional[List["PoolAsset"]],
        future_pool_governor: str,
    ) -> "MsgCreatePoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def join_pool(
        self,
        sender: str,
        pool_id: int,
        share_out_amount: str,
        token_in_maxs: Optional[List["___cosmos_base_v1_beta1__.Coin"]],
    ) -> "MsgJoinPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_pool(
        self,
        sender: str,
        pool_id: int,
        share_in_amount: str,
        token_out_mins: Optional[List["___cosmos_base_v1_beta1__.Coin"]],
    ) -> "MsgExitPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def swap_exact_amount_in(
        self,
        sender: str,
        routes: Optional[List["SwapAmountInRoute"]],
        token_in: "___cosmos_base_v1_beta1__.Coin",
        token_out_min_amount: str,
    ) -> "MsgSwapExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def swap_exact_amount_out(
        self,
        sender: str,
        routes: Optional[List["SwapAmountOutRoute"]],
        token_in_max_amount: str,
        token_out: "___cosmos_base_v1_beta1__.Coin",
    ) -> "MsgSwapExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def join_swap_extern_amount_in(
        self,
        sender: str,
        pool_id: int,
        token_in: "___cosmos_base_v1_beta1__.Coin",
        share_out_min_amount: str,
    ) -> "MsgJoinSwapExternAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def join_swap_share_amount_out(
        self,
        sender: str,
        pool_id: int,
        token_in_denom: str,
        share_out_amount: str,
        token_in_max_amount: str,
    ) -> "MsgJoinSwapShareAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_swap_extern_amount_out(
        self,
        sender: str,
        pool_id: int,
        token_out: "___cosmos_base_v1_beta1__.Coin",
        share_in_max_amount: str,
    ) -> "MsgExitSwapExternAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_swap_share_amount_in(
        self,
        sender: str,
        pool_id: int,
        token_out_denom: str,
        share_in_amount: str,
        token_out_min_amount: str,
    ) -> "MsgExitSwapShareAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_params": request.pool_params,
            "pool_assets": request.pool_assets,
            "future_pool_governor": request.future_pool_governor,
        }

        response = await self.create_pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_join_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "share_out_amount": request.share_out_amount,
            "token_in_maxs": request.token_in_maxs,
        }

        response = await self.join_pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "share_in_amount": request.share_in_amount,
            "token_out_mins": request.token_out_mins,
        }

        response = await self.exit_pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_swap_exact_amount_in(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "routes": request.routes,
            "token_in": request.token_in,
            "token_out_min_amount": request.token_out_min_amount,
        }

        response = await self.swap_exact_amount_in(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_swap_exact_amount_out(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "routes": request.routes,
            "token_in_max_amount": request.token_in_max_amount,
            "token_out": request.token_out,
        }

        response = await self.swap_exact_amount_out(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_join_swap_extern_amount_in(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_in": request.token_in,
            "share_out_min_amount": request.share_out_min_amount,
        }

        response = await self.join_swap_extern_amount_in(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_join_swap_share_amount_out(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_in_denom": request.token_in_denom,
            "share_out_amount": request.share_out_amount,
            "token_in_max_amount": request.token_in_max_amount,
        }

        response = await self.join_swap_share_amount_out(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_swap_extern_amount_out(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_out": request.token_out,
            "share_in_max_amount": request.share_in_max_amount,
        }

        response = await self.exit_swap_extern_amount_out(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_swap_share_amount_in(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_out_denom": request.token_out_denom,
            "share_in_amount": request.share_in_amount,
            "token_out_min_amount": request.token_out_min_amount,
        }

        response = await self.exit_swap_share_amount_in(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.gamm.v1beta1.Msg/CreatePool": grpclib.const.Handler(
                self.__rpc_create_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreatePool,
                MsgCreatePoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/JoinPool": grpclib.const.Handler(
                self.__rpc_join_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinPool,
                MsgJoinPoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/ExitPool": grpclib.const.Handler(
                self.__rpc_exit_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitPool,
                MsgExitPoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountIn": grpclib.const.Handler(
                self.__rpc_swap_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSwapExactAmountIn,
                MsgSwapExactAmountInResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/SwapExactAmountOut": grpclib.const.Handler(
                self.__rpc_swap_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSwapExactAmountOut,
                MsgSwapExactAmountOutResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/JoinSwapExternAmountIn": grpclib.const.Handler(
                self.__rpc_join_swap_extern_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinSwapExternAmountIn,
                MsgJoinSwapExternAmountInResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/JoinSwapShareAmountOut": grpclib.const.Handler(
                self.__rpc_join_swap_share_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinSwapShareAmountOut,
                MsgJoinSwapShareAmountOutResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/ExitSwapExternAmountOut": grpclib.const.Handler(
                self.__rpc_exit_swap_extern_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitSwapExternAmountOut,
                MsgExitSwapExternAmountOutResponse,
            ),
            "/osmosis.gamm.v1beta1.Msg/ExitSwapShareAmountIn": grpclib.const.Handler(
                self.__rpc_exit_swap_share_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitSwapShareAmountIn,
                MsgExitSwapShareAmountInResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def pools(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def num_pools(self) -> "QueryNumPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_liquidity(self) -> "QueryTotalLiquidityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool(self, pool_id: int) -> "QueryPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool_params(self, pool_id: int) -> "QueryPoolParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_shares(self, pool_id: int) -> "QueryTotalSharesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool_assets(self, pool_id: int) -> "QueryPoolAssetsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def spot_price(
        self,
        pool_id: int,
        token_in_denom: str,
        token_out_denom: str,
        with_swap_fee: bool,
    ) -> "QuerySpotPriceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_swap_exact_amount_in(
        self,
        sender: str,
        pool_id: int,
        token_in: str,
        routes: Optional[List["SwapAmountInRoute"]],
    ) -> "QuerySwapExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_swap_exact_amount_out(
        self,
        sender: str,
        pool_id: int,
        routes: Optional[List["SwapAmountOutRoute"]],
        token_out: str,
    ) -> "QuerySwapExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_pools(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.pools(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_num_pools(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.num_pools(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_total_liquidity(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.total_liquidity(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pool(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.pool(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pool_params(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.pool_params(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_total_shares(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.total_shares(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pool_assets(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.pool_assets(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_spot_price(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
            "token_in_denom": request.token_in_denom,
            "token_out_denom": request.token_out_denom,
            "with_swap_fee": request.with_swap_fee,
        }

        response = await self.spot_price(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_estimate_swap_exact_amount_in(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "token_in": request.token_in,
            "routes": request.routes,
        }

        response = await self.estimate_swap_exact_amount_in(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_estimate_swap_exact_amount_out(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "pool_id": request.pool_id,
            "routes": request.routes,
            "token_out": request.token_out,
        }

        response = await self.estimate_swap_exact_amount_out(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.gamm.v1beta1.Query/Pools": grpclib.const.Handler(
                self.__rpc_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolsRequest,
                QueryPoolsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/NumPools": grpclib.const.Handler(
                self.__rpc_num_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNumPoolsRequest,
                QueryNumPoolsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/TotalLiquidity": grpclib.const.Handler(
                self.__rpc_total_liquidity,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalLiquidityRequest,
                QueryTotalLiquidityResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/Pool": grpclib.const.Handler(
                self.__rpc_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolRequest,
                QueryPoolResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/PoolParams": grpclib.const.Handler(
                self.__rpc_pool_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolParamsRequest,
                QueryPoolParamsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/TotalShares": grpclib.const.Handler(
                self.__rpc_total_shares,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalSharesRequest,
                QueryTotalSharesResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/PoolAssets": grpclib.const.Handler(
                self.__rpc_pool_assets,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolAssetsRequest,
                QueryPoolAssetsResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/SpotPrice": grpclib.const.Handler(
                self.__rpc_spot_price,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySpotPriceRequest,
                QuerySpotPriceResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountIn": grpclib.const.Handler(
                self.__rpc_estimate_swap_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySwapExactAmountInRequest,
                QuerySwapExactAmountInResponse,
            ),
            "/osmosis.gamm.v1beta1.Query/EstimateSwapExactAmountOut": grpclib.const.Handler(
                self.__rpc_estimate_swap_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySwapExactAmountOutRequest,
                QuerySwapExactAmountOutResponse,
            ),
        }


from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
