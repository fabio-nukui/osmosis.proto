# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/pool-incentives/v1beta1/genesis.proto, osmosis/pool-incentives/v1beta1/gov.proto, osmosis/pool-incentives/v1beta1/incentives.proto, osmosis/pool-incentives/v1beta1/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import Dict, List

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    # minted_denom is the denomination of the coin expected to be minted by the
    # minting module. Pool-incentives module doesn’t actually mint the coin
    # itself, but rather manages the distribution of coins that matches the
    # defined minted_denom.
    minted_denom: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class LockableDurationsInfo(betterproto.Message):
    lockable_durations: List[timedelta] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DistrInfo(betterproto.Message):
    total_weight: str = betterproto.string_field(1)
    records: List["DistrRecord"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DistrRecord(betterproto.Message):
    gauge_id: int = betterproto.uint64_field(1)
    weight: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the pool incentives module's genesis state."""

    # params defines all the paramaters of the module.
    params: "Params" = betterproto.message_field(1)
    lockable_durations: List[timedelta] = betterproto.message_field(2)
    distr_info: "DistrInfo" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ReplacePoolIncentivesProposal(betterproto.Message):
    """
    ReplacePoolIncentivesProposal is a gov Content type for updating the pool
    incentives. If a ReplacePoolIncentivesProposal passes, the proposal’s
    records override the existing DistrRecords set in the module. Each record
    has a specified gauge id and weight, and the incentives are distributed to
    each gauge according to weight/total_weight. The incentives are put in the
    fee pool and it is allocated to gauges and community pool by the
    DistrRecords configuration. Note that gaugeId=0 represents the community
    pool.
    """

    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    records: List["DistrRecord"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdatePoolIncentivesProposal(betterproto.Message):
    """
    For example: if the existing DistrRecords were: [(Gauge 0, 5), (Gauge 1,
    6), (Gauge 2, 6)] An UpdatePoolIncentivesProposal includes [(Gauge 1, 0),
    (Gauge 2, 4), (Gauge 3, 10)] This would delete Gauge 1, Edit Gauge 2, and
    Add Gauge 3 The result DistrRecords in state would be: [(Gauge 0, 5),
    (Gauge 2, 4), (Gauge 3, 10)]
    """

    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    records: List["DistrRecord"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class QueryGaugeIdsRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryGaugeIdsResponse(betterproto.Message):
    gauge_ids_with_duration: List[
        "QueryGaugeIdsResponseGaugeIdWithDuration"
    ] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryGaugeIdsResponseGaugeIdWithDuration(betterproto.Message):
    gauge_id: int = betterproto.uint64_field(1)
    duration: timedelta = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryDistrInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryDistrInfoResponse(betterproto.Message):
    distr_info: "DistrInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    params: "Params" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryLockableDurationsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryLockableDurationsResponse(betterproto.Message):
    lockable_durations: List[timedelta] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryIncentivizedPoolsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class IncentivizedPool(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    lockable_duration: timedelta = betterproto.message_field(2)
    gauge_id: int = betterproto.uint64_field(3)


@dataclass(eq=False, repr=False)
class QueryIncentivizedPoolsResponse(betterproto.Message):
    incentivized_pools: List["IncentivizedPool"] = betterproto.message_field(1)


class QueryStub(betterproto.ServiceStub):
    async def gauge_ids(self, *, pool_id: int = 0) -> "QueryGaugeIdsResponse":

        request = QueryGaugeIdsRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/osmosis.poolincentives.v1beta1.Query/GaugeIds",
            request,
            QueryGaugeIdsResponse,
        )

    async def distr_info(self) -> "QueryDistrInfoResponse":

        request = QueryDistrInfoRequest()

        return await self._unary_unary(
            "/osmosis.poolincentives.v1beta1.Query/DistrInfo",
            request,
            QueryDistrInfoResponse,
        )

    async def params(self) -> "QueryParamsResponse":

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/osmosis.poolincentives.v1beta1.Query/Params", request, QueryParamsResponse
        )

    async def lockable_durations(self) -> "QueryLockableDurationsResponse":

        request = QueryLockableDurationsRequest()

        return await self._unary_unary(
            "/osmosis.poolincentives.v1beta1.Query/LockableDurations",
            request,
            QueryLockableDurationsResponse,
        )

    async def incentivized_pools(self) -> "QueryIncentivizedPoolsResponse":

        request = QueryIncentivizedPoolsRequest()

        return await self._unary_unary(
            "/osmosis.poolincentives.v1beta1.Query/IncentivizedPools",
            request,
            QueryIncentivizedPoolsResponse,
        )


class QueryBase(ServiceBase):
    async def gauge_ids(self, pool_id: int) -> "QueryGaugeIdsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def distr_info(self) -> "QueryDistrInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def params(self) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def lockable_durations(self) -> "QueryLockableDurationsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def incentivized_pools(self) -> "QueryIncentivizedPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_gauge_ids(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
        }

        response = await self.gauge_ids(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_distr_info(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.distr_info(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_params(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.params(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_lockable_durations(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.lockable_durations(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_incentivized_pools(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.incentivized_pools(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.poolincentives.v1beta1.Query/GaugeIds": grpclib.const.Handler(
                self.__rpc_gauge_ids,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGaugeIdsRequest,
                QueryGaugeIdsResponse,
            ),
            "/osmosis.poolincentives.v1beta1.Query/DistrInfo": grpclib.const.Handler(
                self.__rpc_distr_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryDistrInfoRequest,
                QueryDistrInfoResponse,
            ),
            "/osmosis.poolincentives.v1beta1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/osmosis.poolincentives.v1beta1.Query/LockableDurations": grpclib.const.Handler(
                self.__rpc_lockable_durations,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockableDurationsRequest,
                QueryLockableDurationsResponse,
            ),
            "/osmosis.poolincentives.v1beta1.Query/IncentivizedPools": grpclib.const.Handler(
                self.__rpc_incentivized_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryIncentivizedPoolsRequest,
                QueryIncentivizedPoolsResponse,
            ),
        }
