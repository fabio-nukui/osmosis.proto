# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/incentives/gauge.proto, osmosis/incentives/genesis.proto, osmosis/incentives/params.proto, osmosis/incentives/query.proto, osmosis/incentives/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class Gauge(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    is_perpetual: bool = betterproto.bool_field(2)
    # distribution incentives by third party Rewards are distributed to lockups
    # that are are returned by at least one of these queries
    distribute_to: "_lockup__.QueryCondition" = betterproto.message_field(3)
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)
    # distribution start time
    start_time: datetime = betterproto.message_field(5)
    num_epochs_paid_over: int = betterproto.uint64_field(6)
    filled_epochs: int = betterproto.uint64_field(7)
    distributed_coins: List[
        "__cosmos_base_v1_beta1__.Coin"
    ] = betterproto.message_field(8)


@dataclass(eq=False, repr=False)
class LockableDurationsInfo(betterproto.Message):
    lockable_durations: List[timedelta] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MsgCreateGauge(betterproto.Message):
    is_perpetual: bool = betterproto.bool_field(1)
    # distribution incentives by third party
    owner: str = betterproto.string_field(2)
    distribute_to: "_lockup__.QueryCondition" = betterproto.message_field(3)
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)
    # distribution start time
    start_time: datetime = betterproto.message_field(5)
    num_epochs_paid_over: int = betterproto.uint64_field(6)


@dataclass(eq=False, repr=False)
class MsgCreateGaugeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgAddToGauge(betterproto.Message):
    owner: str = betterproto.string_field(1)
    gauge_id: int = betterproto.uint64_field(2)
    rewards: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgAddToGaugeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params holds parameters for the incentives module"""

    # distribution epoch identifier
    distr_epoch_identifier: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the incentives module's genesis state."""

    # params defines all the parameters of the module
    params: "Params" = betterproto.message_field(1)
    gauges: List["Gauge"] = betterproto.message_field(2)
    lockable_durations: List[timedelta] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ModuleToDistributeCoinsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ModuleToDistributeCoinsResponse(betterproto.Message):
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ModuleDistributedCoinsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ModuleDistributedCoinsResponse(betterproto.Message):
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GaugeByIdRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class GaugeByIdResponse(betterproto.Message):
    gauge: "Gauge" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GaugesRequest(betterproto.Message):
    # pagination defines an pagination for the request.
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class GaugesResponse(betterproto.Message):
    data: List["Gauge"] = betterproto.message_field(1)
    # pagination defines an pagination for the response.
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class ActiveGaugesRequest(betterproto.Message):
    # pagination defines an pagination for the request.
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ActiveGaugesResponse(betterproto.Message):
    data: List["Gauge"] = betterproto.message_field(1)
    # pagination defines an pagination for the response.
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class UpcomingGaugesRequest(betterproto.Message):
    # pagination defines an pagination for the request.
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class UpcomingGaugesResponse(betterproto.Message):
    data: List["Gauge"] = betterproto.message_field(1)
    # pagination defines an pagination for the response.
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class RewardsEstRequest(betterproto.Message):
    owner: str = betterproto.string_field(1)
    lock_ids: List[int] = betterproto.uint64_field(2)
    end_epoch: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class RewardsEstResponse(betterproto.Message):
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryLockableDurationsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryLockableDurationsResponse(betterproto.Message):
    lockable_durations: List[timedelta] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def create_gauge(
        self,
        *,
        is_perpetual: bool = False,
        owner: str = "",
        distribute_to: "_lockup__.QueryCondition" = None,
        coins: Optional[List["__cosmos_base_v1_beta1__.Coin"]] = None,
        start_time: datetime = None,
        num_epochs_paid_over: int = 0,
    ) -> "MsgCreateGaugeResponse":
        coins = coins or []

        request = MsgCreateGauge()
        request.is_perpetual = is_perpetual
        request.owner = owner
        if distribute_to is not None:
            request.distribute_to = distribute_to
        if coins is not None:
            request.coins = coins
        if start_time is not None:
            request.start_time = start_time
        request.num_epochs_paid_over = num_epochs_paid_over

        return await self._unary_unary(
            "/osmosis.incentives.Msg/CreateGauge", request, MsgCreateGaugeResponse
        )

    async def add_to_gauge(
        self,
        *,
        owner: str = "",
        gauge_id: int = 0,
        rewards: Optional[List["__cosmos_base_v1_beta1__.Coin"]] = None,
    ) -> "MsgAddToGaugeResponse":
        rewards = rewards or []

        request = MsgAddToGauge()
        request.owner = owner
        request.gauge_id = gauge_id
        if rewards is not None:
            request.rewards = rewards

        return await self._unary_unary(
            "/osmosis.incentives.Msg/AddToGauge", request, MsgAddToGaugeResponse
        )


class QueryStub(betterproto.ServiceStub):
    async def module_to_distribute_coins(self) -> "ModuleToDistributeCoinsResponse":

        request = ModuleToDistributeCoinsRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/ModuleToDistributeCoins",
            request,
            ModuleToDistributeCoinsResponse,
        )

    async def module_distributed_coins(self) -> "ModuleDistributedCoinsResponse":

        request = ModuleDistributedCoinsRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/ModuleDistributedCoins",
            request,
            ModuleDistributedCoinsResponse,
        )

    async def gauge_by_id(self) -> "GaugeByIdResponse":

        request = GaugeByIdRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/GaugeByID", request, GaugeByIdResponse
        )

    async def gauges(
        self, *, pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "GaugesResponse":

        request = GaugesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/Gauges", request, GaugesResponse
        )

    async def active_gauges(
        self, *, pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "ActiveGaugesResponse":

        request = ActiveGaugesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/ActiveGauges", request, ActiveGaugesResponse
        )

    async def upcoming_gauges(
        self, *, pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "UpcomingGaugesResponse":

        request = UpcomingGaugesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/UpcomingGauges", request, UpcomingGaugesResponse
        )

    async def rewards_est(
        self,
        *,
        owner: str = "",
        lock_ids: Optional[List[int]] = None,
        end_epoch: int = 0,
    ) -> "RewardsEstResponse":
        lock_ids = lock_ids or []

        request = RewardsEstRequest()
        request.owner = owner
        request.lock_ids = lock_ids
        request.end_epoch = end_epoch

        return await self._unary_unary(
            "/osmosis.incentives.Query/RewardsEst", request, RewardsEstResponse
        )

    async def lockable_durations(self) -> "QueryLockableDurationsResponse":

        request = QueryLockableDurationsRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/LockableDurations",
            request,
            QueryLockableDurationsResponse,
        )


class MsgBase(ServiceBase):
    async def create_gauge(
        self,
        is_perpetual: bool,
        owner: str,
        distribute_to: "_lockup__.QueryCondition",
        coins: Optional[List["__cosmos_base_v1_beta1__.Coin"]],
        start_time: datetime,
        num_epochs_paid_over: int,
    ) -> "MsgCreateGaugeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_to_gauge(
        self,
        owner: str,
        gauge_id: int,
        rewards: Optional[List["__cosmos_base_v1_beta1__.Coin"]],
    ) -> "MsgAddToGaugeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_gauge(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "is_perpetual": request.is_perpetual,
            "owner": request.owner,
            "distribute_to": request.distribute_to,
            "coins": request.coins,
            "start_time": request.start_time,
            "num_epochs_paid_over": request.num_epochs_paid_over,
        }

        response = await self.create_gauge(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_to_gauge(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "owner": request.owner,
            "gauge_id": request.gauge_id,
            "rewards": request.rewards,
        }

        response = await self.add_to_gauge(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.incentives.Msg/CreateGauge": grpclib.const.Handler(
                self.__rpc_create_gauge,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGauge,
                MsgCreateGaugeResponse,
            ),
            "/osmosis.incentives.Msg/AddToGauge": grpclib.const.Handler(
                self.__rpc_add_to_gauge,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgAddToGauge,
                MsgAddToGaugeResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def module_to_distribute_coins(self) -> "ModuleToDistributeCoinsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def module_distributed_coins(self) -> "ModuleDistributedCoinsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def gauge_by_id(self) -> "GaugeByIdResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def gauges(
        self, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "GaugesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def active_gauges(
        self, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "ActiveGaugesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def upcoming_gauges(
        self, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "UpcomingGaugesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def rewards_est(
        self, owner: str, lock_ids: Optional[List[int]], end_epoch: int
    ) -> "RewardsEstResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def lockable_durations(self) -> "QueryLockableDurationsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_module_to_distribute_coins(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.module_to_distribute_coins(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_module_distributed_coins(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.module_distributed_coins(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_gauge_by_id(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.gauge_by_id(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_gauges(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.gauges(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_active_gauges(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.active_gauges(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_upcoming_gauges(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.upcoming_gauges(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_rewards_est(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "owner": request.owner,
            "lock_ids": request.lock_ids,
            "end_epoch": request.end_epoch,
        }

        response = await self.rewards_est(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_lockable_durations(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.lockable_durations(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.incentives.Query/ModuleToDistributeCoins": grpclib.const.Handler(
                self.__rpc_module_to_distribute_coins,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModuleToDistributeCoinsRequest,
                ModuleToDistributeCoinsResponse,
            ),
            "/osmosis.incentives.Query/ModuleDistributedCoins": grpclib.const.Handler(
                self.__rpc_module_distributed_coins,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModuleDistributedCoinsRequest,
                ModuleDistributedCoinsResponse,
            ),
            "/osmosis.incentives.Query/GaugeByID": grpclib.const.Handler(
                self.__rpc_gauge_by_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                GaugeByIdRequest,
                GaugeByIdResponse,
            ),
            "/osmosis.incentives.Query/Gauges": grpclib.const.Handler(
                self.__rpc_gauges,
                grpclib.const.Cardinality.UNARY_UNARY,
                GaugesRequest,
                GaugesResponse,
            ),
            "/osmosis.incentives.Query/ActiveGauges": grpclib.const.Handler(
                self.__rpc_active_gauges,
                grpclib.const.Cardinality.UNARY_UNARY,
                ActiveGaugesRequest,
                ActiveGaugesResponse,
            ),
            "/osmosis.incentives.Query/UpcomingGauges": grpclib.const.Handler(
                self.__rpc_upcoming_gauges,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpcomingGaugesRequest,
                UpcomingGaugesResponse,
            ),
            "/osmosis.incentives.Query/RewardsEst": grpclib.const.Handler(
                self.__rpc_rewards_est,
                grpclib.const.Cardinality.UNARY_UNARY,
                RewardsEstRequest,
                RewardsEstResponse,
            ),
            "/osmosis.incentives.Query/LockableDurations": grpclib.const.Handler(
                self.__rpc_lockable_durations,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockableDurationsRequest,
                QueryLockableDurationsResponse,
            ),
        }


from .. import lockup as _lockup__
from ...cosmos.base import v1beta1 as __cosmos_base_v1_beta1__
from ...cosmos.base.query import v1beta1 as __cosmos_base_query_v1_beta1__
